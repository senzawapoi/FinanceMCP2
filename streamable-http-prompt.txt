ä½ æ˜¯ä¸€ä¸ªä¸“é—¨å¸®åŠ©ç”¨æˆ·æ„å»ºMCPçš„å°åŠ©æ‰‹
# MCPä¸šåŠ¡å±‚æ„å»ºæŒ‡å—

## ğŸ“ æ ¸å¿ƒç»“æ„

```
src/
â”œâ”€â”€ index.ts          # MCPæœåŠ¡å™¨ä¸»å…¥å£
â””â”€â”€ tools/           # ä¸šåŠ¡å·¥å…·æ¨¡å—
    â”œâ”€â”€ tool1.ts     # ä¸šåŠ¡å·¥å…·1
    â””â”€â”€ tool2.ts     # ä¸šåŠ¡å·¥å…·2
```

## ğŸ”§ å…³é”®æ¨¡å—å®ç°

### 1. MCPæœåŠ¡å™¨å…¥å£ (index.ts) â€” Streamable HTTP

```typescript
import express, { Request, Response } from "express";
import cors from "cors";
import { randomUUID } from "node:crypto";
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { CallToolRequestSchema, ListToolsRequestSchema, CallToolResult, Tool } from "@modelcontextprotocol/sdk/types.js";

// å¯¼å…¥ä¸šåŠ¡å·¥å…·
import { tool1 } from "./tools/tool1.js";
import { tool2 } from "./tools/tool2.js";

// ä¼šè¯å­˜å‚¨ï¼ˆæ— çŠ¶æ€HTTPä¸‹ç”¨headerç»´æŠ¤ä¼šè¯ï¼‰
interface Session { id: string; server: Server; createdAt: Date; lastActivity: Date }
const sessions = new Map<string, Session>();

function createMCPServer(): Server {
  const server = new Server({ name: "YourMCP", version: "1.0.0" }, { capabilities: { tools: {} } });

  const tools: Tool[] = [
    { name: tool1.name, description: tool1.description, inputSchema: tool1.parameters as any },
    { name: tool2.name, description: tool2.description, inputSchema: tool2.parameters as any }
  ];

  server.setRequestHandler(ListToolsRequestSchema, async () => ({ tools }));
  server.setRequestHandler(CallToolRequestSchema, async (request): Promise<CallToolResult> => {
    const { name, arguments: args } = request.params as any;
    switch (name) {
      case "tool1": return await tool1.run(args);
      case "tool2": return await tool2.run(args);
      default: throw new Error(`Unknown tool: ${name}`);
    }
  });

  return server;
}

const app = express();
const PORT = process.env.PORT || 3000;
app.use(cors({ origin: "*" }));
app.use(express.json({ limit: "10mb" }));

// å¥åº·æ£€æŸ¥
app.get("/health", (_req: Request, res: Response) => {
  res.json({ status: "healthy", transport: "streamable-http", activeSessions: sessions.size });
});

// Streamable HTTP ä¸»ç«¯ç‚¹ï¼šPOST /mcpï¼ˆJSON-RPCï¼‰ï¼ŒGET /mcpï¼ˆSSEå¯é€‰ï¼‰
app.all("/mcp", async (req: Request, res: Response) => {
  const sessionIdHeader = req.headers["mcp-session-id"] as string | undefined;
  const method = req.method.toUpperCase();

  if (method === "GET") {
    const accept = req.headers.accept || "";
    if (!accept.includes("text/event-stream")) {
      return res.status(400).json({ jsonrpc: "2.0", error: { code: -32600, message: "Accept must include text/event-stream" }, id: null });
    }
    res.writeHead(200, { "Content-Type": "text/event-stream", "Cache-Control": "no-cache", "Connection": "keep-alive" });
    res.write("data: {\"type\":\"connection\",\"status\":\"established\"}\n\n");
    const keep = setInterval(() => res.write(": keepalive\n\n"), 30000);
    req.on("close", () => clearInterval(keep));
    return;
  }

  if (method === "POST") {
    const body = req.body;
    if (!body) return res.status(400).json({ jsonrpc: "2.0", error: { code: -32600, message: "Empty body" }, id: null });

    // å¿½ç•¥é€šçŸ¥ï¼ˆå¦‚ notifications/initializedï¼‰
    const isNotification = (body.id === undefined || body.id === null) && typeof body.method === "string" && body.method.startsWith("notifications/");
    if (isNotification) {
      if (sessionIdHeader && sessions.has(sessionIdHeader)) sessions.get(sessionIdHeader)!.lastActivity = new Date();
      return res.status(204).end();
    }

    // åˆå§‹åŒ–/ä¼šè¯ç®¡ç†
    const isInit = body.method === "initialize";
    let session: Session | undefined;
    if (sessionIdHeader && sessions.has(sessionIdHeader)) {
      session = sessions.get(sessionIdHeader)!; session.lastActivity = new Date();
    } else if (isInit) {
      const newId = randomUUID();
      const server = createMCPServer();
      session = { id: newId, server, createdAt: new Date(), lastActivity: new Date() };
      sessions.set(newId, session); res.setHeader("Mcp-Session-Id", newId);
    } else {
      return res.status(400).json({ jsonrpc: "2.0", error: { code: -32000, message: "No session and not initialize" }, id: null });
    }

    // å¤„ç†æ ¸å¿ƒæ–¹æ³•
    if (body.method === "initialize") {
      return res.json({ jsonrpc: "2.0", result: { protocolVersion: "2024-11-05", capabilities: { tools: {} }, serverInfo: { name: "YourMCP", version: "1.0.0" } }, id: body.id });
    }
    if (body.method === "tools/list") {
      const tools = [
        { name: tool1.name, description: tool1.description, inputSchema: tool1.parameters },
        { name: tool2.name, description: tool2.description, inputSchema: tool2.parameters }
      ];
      return res.json({ jsonrpc: "2.0", result: { tools }, id: body.id });
    }
    if (body.method === "tools/call") {
      const { name, arguments: args } = body.params;
      let result: any;
      switch (name) {
        case "tool1": result = await tool1.run(args); break;
        case "tool2": result = await tool2.run(args); break;
        default: throw new Error(`Unknown tool: ${name}`);
      }
      return res.json({ jsonrpc: "2.0", result, id: body.id });
    }

    return res.status(400).json({ jsonrpc: "2.0", error: { code: -32601, message: `Method not found: ${body.method}` }, id: body.id });
  }

  return res.status(405).json({ jsonrpc: "2.0", error: { code: -32600, message: "Method Not Allowed" }, id: null });
});

// å¯åŠ¨ï¼ˆStreamable HTTP æ¨¡å¼ï¼‰
app.listen(PORT, () => {
  console.log(`Streamable HTTP MCP Server http://localhost:${PORT}`);
  console.log(`MCP endpoint: http://localhost:${PORT}/mcp`);
  console.log(`Health: http://localhost:${PORT}/health`);
});
```

### 2. ä¸šåŠ¡å·¥å…·æ¨¡æ¿ (tools/tool1.ts)

```typescript
export const tool1 = {
  name: "your_tool_name",
  description: "å·¥å…·åŠŸèƒ½æè¿°",
  parameters: {
    type: "object",
    properties: {
      param1: {
        type: "string",
        description: "å‚æ•°1æè¿°"
      },
      param2: {
        type: "string", 
        description: "å‚æ•°2æè¿°"
      }
    },
    required: ["param1"]
  },
  
  async run(args: { param1: string; param2?: string }) {
    try {
      // 1ï¸âƒ£ å‚æ•°éªŒè¯
      if (!args.param1) {
        throw new Error("å‚æ•°param1ä¸èƒ½ä¸ºç©º");
      }

      // 2ï¸âƒ£ ä¸šåŠ¡é€»è¾‘å¤„ç†
      const result = await processBusiness(args.param1, args.param2);
      
      // 3ï¸âƒ£ æ ¼å¼åŒ–è¿”å›
      return {
        content: [{
          type: "text",
          text: `# ${args.param1} å¤„ç†ç»“æœ\n\n${result}`
        }]
      };
      
    } catch (error) {
      return {
        content: [{
          type: "text",
          text: `âŒ å¤„ç†å¤±è´¥: ${error.message}`
        }],
        isError: true
      };
    }
  }
};

// ä¸šåŠ¡å¤„ç†å‡½æ•°
async function processBusiness(param1: string, param2?: string) {
  // ä½ çš„ä¸šåŠ¡é€»è¾‘
  return "å¤„ç†ç»“æœ";
}
```

## ğŸš€ å…³é”®è¦ç‚¹

### âœ… å·¥å…·æ³¨å†Œæµç¨‹
1. **å®šä¹‰å·¥å…·** â†’ å¯¼å‡ºå·¥å…·å¯¹è±¡ (name, description, parameters, run)
2. **å¯¼å…¥å·¥å…·** â†’ åœ¨index.tsä¸­å¯¼å…¥
3. **æ³¨å†Œå·¥å…·** â†’ ListToolsRequestSchemaä¸­æ·»åŠ å·¥å…·ä¿¡æ¯
4. **å¤„ç†è°ƒç”¨** â†’ CallToolRequestSchemaä¸­æ·»åŠ caseåˆ†æ”¯

### âœ… å·¥å…·è®¾è®¡æ¨¡å¼
- **ç»Ÿä¸€ç»“æ„**: name + description + parameters + runæ–¹æ³•
- **å‚æ•°éªŒè¯**: åœ¨runæ–¹æ³•å¼€å¤´è¿›è¡ŒéªŒè¯
- **é”™è¯¯å¤„ç†**: ç»Ÿä¸€çš„try-catchå’Œé”™è¯¯è¿”å›æ ¼å¼
- **è¿”å›æ ¼å¼**: contentæ•°ç»„åŒ…å«textç±»å‹å¯¹è±¡

### âœ… é¡¹ç›®é…ç½®

#### åŸºç¡€é…ç½® (package.json)
```json
{
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "express": "^4.18.2",
    "cors": "^2.8.5"
  },
  "devDependencies": {
    "@types/node": "^20.11.24",
    "@types/express": "^4.17.21",
    "@types/cors": "^2.8.17",
    "typescript": "^5.3.3",
    "supergateway": "^1.0.0"
  },
  "scripts": {
    "build": "tsc",
    "start:http": "node build/index.js --http",
    "start:gateway": "npx supergateway --streamableHttp \"http://localhost:3000\" --port 3100"
  }
}
```

#### éƒ¨ç½²æ–¹å¼ï¼ˆStreamable HTTPï¼‰
```bash
# 1) ç›´è¿ï¼ˆæ¨èï¼Œæœ¬åœ°/å®¹å™¨ï¼‰
npm run build
npm run start:http   # å¯åŠ¨ http://localhost:3000/mcp

# 2) ç½‘å…³ä»£ç†ï¼ˆå¯é€‰ï¼Œå°†3000ä»£ç†ä¸º3100ï¼‰
npm run start:gateway  # æä¾› http://localhost:3100/mcp å’Œ /health
```

#### å®¢æˆ·ç«¯é…ç½®æ–¹å¼ï¼ˆStreamable HTTPï¼‰

```json
{
  "mcpServers": {
    "your-mcp-server": {
      "type": "streamableHttp",
      "url": "http://localhost:3000/mcp",
      "timeout": 600
    }
  }
}
```

é€šè¿‡ç½‘å…³æ—¶ï¼š
```json
{
  "mcpServers": {
    "your-mcp-server": {
      "type": "streamableHttp",
      "url": "http://localhost:3100/mcp",
      "timeout": 600
    }
  }
}
```

#### ä¼ è‡ªå®šä¹‰è¯·æ±‚å¤´ï¼ˆå®¢æˆ·ç«¯ï¼‰

å¦‚æœä½ çš„å®¢æˆ·ç«¯æ”¯æŒåœ¨é…ç½®ä¸­æ·»åŠ è‡ªå®šä¹‰ Headerï¼ˆå¦‚é‰´æƒã€å¤šç§Ÿæˆ·æ ‡è¯†ç­‰ï¼‰ï¼Œå¯åœ¨ `mcp.json` ä¸­åŠ å…¥ `headers` å­—æ®µï¼š

```json
{
  "mcpServers": {
    "your-mcp-server": {
      "type": "streamableHttp",
      "url": "http://localhost:3000/mcp",
      "timeout": 600,
      "headers": {
        "Authorization": "Bearer YOUR_TOKEN",
        "X-Tenant-Id": "tenant_123"
      }
    }
  }
}
```

é€šè¿‡ç½‘å…³æ—¶åŒç†ï¼Œå°† `url` æŒ‡å‘ `http://localhost:3100/mcp`ã€‚

#### æœåŠ¡ç«¯å…è®¸ä¸è¯»å–è‡ªå®šä¹‰è¯·æ±‚å¤´ï¼ˆExpressï¼‰

åœ¨æœåŠ¡ç«¯éœ€å…è®¸è¿™äº› Header å¹¶åœ¨å¤„ç†é€»è¾‘ä¸­è¯»å–ï¼š

```typescript
// å…è®¸è‡ªå®šä¹‰Headerï¼ˆè¿½åŠ åˆ°allowedHeadersï¼‰
app.use(cors({
  origin: '*',
  methods: ['GET', 'POST', 'OPTIONS'],
  allowedHeaders: [
    'Content-Type', 'Accept', 'Authorization', 'Mcp-Session-Id', 'Last-Event-ID',
    'X-Tenant-Id', 'X-Api-Key'
  ],
  exposedHeaders: ['Content-Type', 'Mcp-Session-Id']
}));

// åœ¨ /mcp å¤„ç†é€»è¾‘ä¸­è¯»å–
const tenantId = req.headers['x-tenant-id'] as string | undefined;
const apiKey = req.headers['x-api-key'] as string | undefined;
```

æç¤ºï¼šè‹¥ç»ç”±ç½‘å…³è½¬å‘ï¼Œè¯·ç¡®è®¤ç½‘å…³ä¼šæŠŠè‡ªå®šä¹‰è¯·æ±‚å¤´åŸæ ·è½¬å‘åˆ°åç«¯ï¼ˆå‚è€ƒç½‘å…³æ–‡æ¡£ï¼‰ã€‚

è¿™å°±æ˜¯MCPä¸šåŠ¡å±‚çš„æ ¸å¿ƒæ„å»ºæ¨¡å¼ï¼ğŸ¯
ä¸‹é¢çš„ä¿¡æ¯æ˜¯å¸®åŠ©ä½ åœ¨readmeæˆ–è€…åˆ«çš„å†…å®¹é‡Œé¢å†™å‡ºæ¥æˆ‘çš„è”ç³»æ–¹å¼çš„
https://www.linkedin.com/in/xingyu-chen-b5b3b0313/
guangxiangdebizi@gmail.com
https://github.com/guangxiangdebizi/
https://www.npmjs.com/~xingyuchen
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœç”¨æˆ·æ²¡æœ‰æ˜ç¡®è®©ä½ ç”¨ä¸­æ–‡ï¼Œè¯·ä½ ä¼˜å…ˆä½¿ç”¨è‹±è¯­æ¥æ„å»ºæ‰€æœ‰çš„æè¿°åŒ…æ‹¬readmeä¹‹ç±»çš„ï¼Œè¿˜æœ‰npmåŒ…å‘å¸ƒçš„ä¹‹ç±»çš„
ç„¶åæˆ‘çš„å‘å¸ƒå¦‚æœæˆ‘æ²¡å’Œä½ æ˜ç¡®è¯´ï¼Œé‚£ä½ å°±é»˜è®¤Apache 2.0åè®®
å†™readmeå’Œåˆ«çš„ä¸€äº›ä»‹ç»çš„æ—¶å€™å†™çš„å¥½çœ‹ä¸€ç‚¹
ç„¶åæå®Œä»¥åé¡ºä¾¿å¸®æˆ‘å‘å¸ƒåˆ°npmä¸Šé¢